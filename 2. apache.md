# apache HTTP Server
он будет разобран детально, так как система очень массовая, очень гибкая, от того уязвимостей в ней много и часть из них абсолютно непринимы при различных обстоятельствах.  
## распространненность и иная общедоступная информация
кроссплатформенное свободно распространяемый веб-сервер.   
С апреля 1996 и до настоящего времени является самым популярным HTTP-сервером в Интернете.  
язык: C  
дата создания: 1995  
ирония: назывался в шутку «в заплатках», так как закрывал заплатками ошибки NCSA, а теперь сам весь в заплатках.  
конфигурация: текстовые *.conf файлы (httpd.conf - по умолчанию, extra/httpd-vhosts.conf - для виртуальных хостов)  


## "детские" проблемы
* запуск от УЗ с избыточными привилегиями
* включенный модуль выполнения php без нужды
* возможность загружать файлы без проверок
* ошибка конфигурации и возможность использовать ../../ в URL
* ошибки в backend сайтов, которые находятся на веб-сервере.


## определения наличия на узле
### сетевой
если доступ к узлу только сетевой и сканнер является удаленным:  
nmap, скорее всего нас будут интересовать толко порты 80 и 443, но хорошо также 8080 (-p80,443,8080). (хотя -p- тоже прекрасно, если один из сервисов http)  
в возвращаемых дынных будет заголовок http-server-header Apache/*   
также можно воспользоваться скриптом для nmap http-apache-server-status  
что нам важно вытащить из этой информации: версию Apache  
также неплохо понять что за операционная система перед нами (так как сервер явялется кросс платформенным), осмотрев хост по всем портам (-p-), по всем доступным портам общим сканом (-A)  


### если есть edr или шелл на хост
значит у нас фактически есть данные какая ОС на хосте  
для Debian/Ubuntu Linux необходимо выполнить команду apache2 -v  
CentOS/RHEL/Fedora Linux server: httpd -v  
для Windows необходимо найти httpd.exe (если он не прописан в PATH) и использовать команду ":\[Apache directories]\bin\httpd.exe" -v  
собственно отзыв по команде и сравнение версий с реальностью нам даст информацию о факте установки.  
также необходимо проверить факт запуска приложения: sudo ss -ltnup | grep "apache"  

## получив версию 
получив версию мы понимаем какие уязвимости вообще применимы.  
то есть, если у нас установлен Apache 2.4.50, в котором исправлены уязвимости: CVE-2021-41524 и CVE-2021-41773, проверить их, конечно, можно, но вероятность крайне мала, тоже касается уязвимостей в более ранних версиях.

## работа с известными уязвимостями
все уязвимости можно разделить на несколько категорий
* работа с путем внутри, например:
    CVE-2021-41773, закрытая 2.4.49 в связке с миссконфигом, которые давали читать ../../../../etc/passwd и выполнять код  
    для проверки нужно знать:
    + версия ПО
    + параметр конфигов, определяющий возможности использования alias-ов
* работа с файлами, определенного расширения, лежащими внутри сайта, например:
    CVE-2021-44790, закрыта 2.4.51, при обращении к lua-файлу с правильными заголовками можно "положить" веб-сервер  
    для проверки нужно знать:
    + версию ПО
    + файловую структуру внутри веб сервера
    + параметр конфига можно ли загружать файлы на веб-сервер из веба (или параметры бэкэнда)
    + блэклистинг расширений файлов в конфиге, котырые отображаются на сайте
* общеизвестные проблемы бэкенда, по типу SQL инъекций, LFE, RFE

# итого
## приоритет
высокий, так как:
1) массовая. в мире каждый третий заказчик
1) массовая в РФ. может быть установлена у каждого 6го заказчика;
1) часто явяляется основой другого ПО, администрирование котрого осуществляется на базе Apache;
2) описанная. по ней куча информации, по настройкам;
3) вендор ведет patch notes и описания релизов с закрытыми уязвимостями;
4) opensource, можно развернуть в лаборатории и тестировать как угодно;
5) ПОКи скриптов.

## модель данных для Apache
* конфиг с разделением с каждым виртуальным сайтом
* версия
* дерево файлов и папок
* cwd
* если нужен респонз, то ID приложений веб-сервера
* запускается ли включении хоста и чем
* под какой УЗ
* запущено сейчас
* установленные расширения поверх (их имя, версия, если висят на другом порту, то каком и в какую сеть)

## архитектура проверки
* обнаружение узла (сетевой скан)
* обнаружение ПО на узле (сетевой скан и запуск команд на хосте)
* сбор информации о ПО (сетевой скан и запуск команд на хосте)
* сбор статуса: запущено, куда смотрит ((сетевой скан и запуск команд на хосте))
* проверка версии, если на существующую версию есть уязвимости (работа с моделью)  
    результат: отображение применимых в теории уязвимостей
* проверка конфигов и модели на применимость уязвимостей (работа с моделью)    
    результат: повышение уровня важности подошедших уязвимостей из первого списка
* запуск скриптов PenTest для фактической проверки, на подходящие уязвимости (модуль сетевого пентеста)  
    результат: при успешном прохождении теста на проникновение, максмальное повышение значимости уязвимости из первого списка.
* (опционально) запуск скриптов PenTest, для всех версий Apache (модуль сетевого пентеста) 
    результат: вера в разработчиков, старые закрытые CVE все еще закрытые

## стек технологий для проверки
* nmap
* агент, в виде edr или возможность удаленного выполнения команд на хосте
* PenTest модуль с заранее описанными скриптами (BlackBox, BAS, anyelse)

## требования
### требования к сканнеру
* скорость проверки (ресурсы необходимые на выполнение), на полу-пустом лабораторном стенде скан не должен занимать более 1 минуты
* скан в режиме пен-тест не должен сломать систему или предупредить о том какие проверки могут вызвать негативные последствия, например DoS. 
* скан EDR не должен занимать первый приоритет процессора, так как может вызвать непреднамеренный DoS

### требование к разработке сканнера
* соответствие кода ТЗ эксперта
* комментирование кода и описание применяемых функций
* логгирование запуска фукнции, выполнения и полноценное описание ошибки в случае провала, с кодом ссылающимся на документацию
* дозапись в ТЗ какие модули/функции выполняют тот или иной блок.
* при многократном переиспользвоании вынос блоков в отдельную директорию, с максимально возможным описанием

### требования к экспертной команде
* понятное ТЗ
* отзывчивость при вопросах от команды разработки
* проработка возможных проблем при скане, описание возможных ошибок
* тестирование, аппрув
* поддержка в случае проблем

## процессы (если будет необходимость, то могу представить в формате IDEF0)
0) анализ источника (приоритет, надо ли вообще);
1) поиск информации по существующим источнику, документации, CVE;
2) написание ТЗ на автоматизацию поиска CVE (с каких сайтов нужны упоминания, где сайт вендора с патч-ноутс (формат представления));
3) стендирование;
4) анализ конфигов и иных источников данных для модели;
5) составление модели;
6) написание ТЗ на аудит;
7) составление ТЗ на ПенТест (сбор скриптов, составление новых);
8) ревью скриптов по ТЗ;
9) тестирование скриптов;
10) поддержка по выходу новых версий или багов.

### оргизационные вопросы
* взаимодействие команд
* умение команд общаться друг с другом
* понимание стека технологий и возможностей обеих команд
* доступ к трекеру и понимание загрузки команд
* умение вставлять в план задачи для минимально возможных швов между командами. Если в эксперта летит задача, которая точно перейдет в разработку, то задачу на разработку можно заводить сразу, ставя старт_тайм как время выполнение экспертной составляющей + 2 недели (форс-мажоры). это позволит минимаизировать потери знаний эксперта и ускорит общее время выполнение.
* оценка и минимизация задач пролетающих мимо стандартного пайплайна (сверху). 

## человеко-ресурсы и временные рамки
1) эксперт 1 месяц - минимальная работа то есть VM, минимальная модель (версия и где ее взять), либо 2 месяца (+ТЗ атак, модель достаточная для комплаенса)
2) разработчик 2 недели - реализация всех ТЗ и тестирование, если с атаками, то еще 1-2 недели.

максимальное время от взяли в работу → появилось в продукте: 4 месяца

## Риски
* отсутствие документации на конфигурирование, может увеличить срок реализации;
* нераспространенность ПО и как следствие малая известность атак и уязвимостей, которые могут найтись в процессе, может оказаться что ВМ будет бесполезен и не отображать реальную уязвимость ПО и инфраструктуры;
* отсутствие методов подключения сканнера, если придется добавлять фундаментальный функционал в сканнер, то срок его реализации вырастет;
* плохие договоренности между командами, если эксперт не будет ревьювить своевременно разработчик может переключиться на другую задачу и получится бесконечное ожидание друг друга, что увеличит сроки.